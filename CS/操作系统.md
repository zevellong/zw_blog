# 操作系统

## 导论

### 操作系统的定义、作用

* helloword --> 命令行、图标 --> 操作系统磁盘读hello --> 创建进程 （文件映射）
* --> 进程调度 --> 执行hello --> 第一条hello指令 --> 缺页异常 --> 分配物理内存 -->
* 读入磁盘到内存 --> 执行puts函数 。。。



* 定义：操作系统是计算机系统的一个系统软件，是一个程序模块的集合

  * **合理、有效**的管理计算机软硬件资源

  * 合理的组织工作流程、控制程序的执行、提供各种服务

  * 灵活**方便**地使用计算机，使整个系统高效运行

  *  

  * 有效：系统的效率， 资源利用率

  * 合理：公平

  * 方便使用：用户界面，编程接口

  * **作用**

  * 资源的管理者：硬件：CPU、内存、设备、 软件：文件

    * 跟踪记录使用的状况--数据结构
    * 资源的分配策略--算法
      * 静态分配策略、动态分配策略
    * 资源的分配和回收
    * 提高资源的利用率
    * 保护资源的使用
    * 协调多个资源请求的冲突

* 五大功能
  * 进程线程管理
  * 存储管理
  * 文件管理
  * 设备管理
  * 用户接口
* 有效的管理资源
* 系统服务的提供者
  * 典型的服务：进程，IO
* 对硬件资源的扩展
  * 应用程序与硬件建立了一个等价的扩展机器
  * 提高可移植性

### 主要特征 

* **并发**：指处理多个同时性活动的能力
  * 活动切换、保护、相互依赖
  * 宏观上多个程序同时执行；
  * 微观上只能一个程序真正执行，但cpu轮流执行
* **并行**：与并发相似，指不同程序同时在多个硬件部位上执行
* **共享**：共享有效的资源
  * 合理的分配，交替使用
  * 互斥共享，同时共享
* **虚拟**：一个物理实体映射多个逻辑的实体--分时或分空间
  * 虚拟是管理的重要手段，提高资源的利用率
* **随机**：随时对以不可预测的次序发生的事件响应进行处理
  * 执行的时候走走停停
  * 难以重现错误

### 典型的操作系统架构

* Windows
* Unix
* Linux
* Android

### 操作系统的分类

* 硬件技术的发展
* 应用需求的发展
* 软件新技术的出现
* **目标**
* 充分利用硬件
* 提供更好的服务



* 传统操作系统分类
* 批处理操作系统
  * 批量收集作业--> 输入计算机 --> 自动依次的执行
  * **追求的目标**：提高资源利用率，吞吐量
  * **成批**：只能等待作业，不能干预作业的执行
  * **问题**：输入输出时，cpu等待
  * **解决方案**：卫星机
  * **SPOOLING技术**：假脱机技术
    * 思想：利用磁盘做缓冲，输入、输出、计数分别组织任务流，使IO和计算真正并行
    * 作用加载到输入井
    * 调度作业
    * 运行的结果输出到输出井
    * 输出井输出到打印机
* 分时操作系统
  * **时间片**：CPU的时间划分为多个片段
  * **追求目标**：及时响应，命令给出到应答的时间
* 通用操作系统
  * 分时与批处理结合
  * 原则：分时优先，批处理在后
  * 前台，后台
* 实时操作系统
  * 及时的响应外部事件的请求
  * 实时过程控制：工业控制，航空，军事
  * 实时通信处理：银行，股市
  * 追求目标：严格的时间响应，高可靠性
  * 硬实时，软实时
* 个人计算机操作系统
  * 计算机在某一时间为单用户服务
  * 追求目标：界面友好，丰富的软件
* 网络操作系统
  * 基于计算机网络
  * 网络协议标准的软件
  * 追求目标：网络通信，共享资源
* 分布式操作系统
  * 以计算机网络为基础，或多处理器，基本特征是处理分布在不同的计算机上
  * 是一个统一的操作系统，允许多个操作系统协同
* 嵌入式操作系统
  * 各种设备，专门特定的功能
  * 大设备，可以不是计算机
  * 通常对时间有严格要求
* 智能卡：包含cpu芯片的卡片
  * 耗电，存储空间限制
  * 专用的操作系统

## 操作系统运行环境和状态

#### CPU状态

* 处理器由 运算器，控制器，一系列的寄存器，高速缓存
* 寄存器
  * 用户可见寄存器:
  * 控制和状态寄存器：pc，IR，psw
* 操作系统的需求-保护：
  * 并发和共享
  * 处理器有不同发特权级
  * OS与用户隔离
* 处理器的状态（mode）
  * 现代处理器多为2，3，4种状态
  * psw专门设置级别
* 两种状态
* 内核态：运行OS程序
* 用户态：运行用户程序
* 特权指令：只能由OS使用，用户不能使用
  * 启动IO，内存清零，修改psw，设置时钟，允许、禁止中断，停机
* 非特权指令：用户指令
  * 控制转移，算数运算，访管指令，取数指令
* x86， R0,R1,R2,R3
* 用户态-->内核态：唯一途径  中断异常陷入机制
* 内核--> 用户：设置psw

#### 中断/异常机制

* 设备的中断
* OS捕获的服务请求
* 用户执行过程的破坏性活动
* ...
* 概念：cpu对系统发生某个事件作出的一种反应
* 引入：设备完成后，向cpu汇报
* 异常的引入：cpu指令本身出现了问题



* 事件
* 中断（外中断）
  * IO中断
  * 时钟中断
  * 硬件故障
* 异常（内中断）
  * 系统调用
  * 页故障、页错误
  * 保护性异常
  * 断点指令
  * 其他程序性异常（算术溢出）



### 中断异常的工作原理

中断响应

- 开始 --> 取指令 --> 执行指令 --> 检查指令，处理中断

- 中断向量
  - 一个内存单元，中断处理程序的入口地址和程序运行时的处理机状态机
- 中断响应的过程
  - 设备发中断信号
  - 硬件保护现场
  - 查中断码表
  - 把中断处理程序入口地址推送到响应寄存器
  - 执行中断处理程序
- 中断处理程序
  - 设计操作系统时，为每一类中断、异常事件编好处理程序，设置中断向量表
  - 运行时，中断硬件将cpu控制权交给中断处理程序
    - 保存相关寄存器信息
    - 分析中断原因
    - 执行对应的处理程序
    - 恢复现场，返回程序
- 例
- 打印机给CPU发送中断信号（硬件）
  - CPU处理当前指令检测到中断， 判断中断源并向相关设备发送信号
- CPU开始为软件处理做准备（软件）
  - 处理器切换内核态
  - 保存中断程序的重要环境，pc，psw
  - CPU查中断向量表，获取入口地址，设置新PC，新的指令周期开始时，转移cpu控制权
- 中断处理程序开始工作
  - 在系统栈保存现场信息
  - 检查IO设备状态信息，操纵IO设备或在设备与内存间传送数据
- 中断处理结束时，CPU检测中断返回指令，从系统栈恢复上下文环境，cpu状态恢复，psw和pc恢复中断前的值，cpu开始新的指令周期
- 中断处理程序
- IO操作正常结束
  - 有程序正在等待，唤醒
  - 若要继续IO操作，需要准备好数据重新启动IO
- IO操作出现错误
  - 需要重新执行失败的IO
  - 重试的次数有线，到达时系统判定硬件故障

### 系统调用

* 用户在编程时，可以调用的OS功能
* 是OS提供给编程人员的接口
* 使cpu用户态到内核态
* 进程控制，进程通信，文件，目录，设备，信息维护
* 系统调用，库函数，API，内核函数
* 系统调用机制的设计
  * 中断异常机制，支持系统调用服务的实现
  * 选择一条指令，访管指令，用户态到内核态
  * 系统调用号和参数，事先给定一个编号
  * 系统调用表，存放入口地址
* 参数传递过程的问题
  * 陷入指令自带参数
  * **通用寄存器**
  * 内存开辟栈



## 进程/线程模型

- 并发环境：一段时间间隔内，单个处理器有两个或以上程序同时处于开始运行但尚未结束的状态，且次序不是实现确定的
- 进程：具有独立功能的程序关于**某个数据集合上**的**一次独立活动**，是系统进行的资源分配和**调度**的独立单位
  - 程序的一次调度过程
  - 正在运行程序的抽象
  - 将一个CPU变换多个虚拟的CPU
  - 系统资源以进程为单位分配，内存，文件
    - 每个具有独立的地址空间
  - OS使用CPU调度交给进程控制权
- 进程控制块PCB
  - 进程描述符，进程属性
  - 用于管理进程的一个数据结构
  - 记录各种属性，描述进程的动态变化过程
  - **PCB是系统感知进程存在的唯一标志**
    - 进程与CPU一一对应
  - 进程表，所有pcb的集合
- PCB构成
- 进程的描述信息
  - PID（唯一），进程名，UID，进程组关系
- 进程控制信息
  - 当前状态
  - 优先级
  - 代码入口地址
  - 程序的磁盘地址
  - 运行的统计信息，执行时间，页面调度
  - 进程间同步和通信
  - 进程的队列指针
  - 进程间消息队列指针
- 所有的资源和使用情况
- CPU的现场信息
  - 寄存器值（通用，PC，PSW，栈指针）
  - 指向该进程页表的指针



### 进程的状态及转换

- 进程的三种基本状态：
  - 运行态，占有CPU，运行
  - 就绪态，具备运行的条件，无空闲的CPU
  - 等待态，等待某一事件，不能运行
- 进程的其他状态--五状态模型
  - 创建态
    - 创建了PCB
    - 资源有效不能执行
  - 终止态
    - 终止执行后，进入该态
    - 可完成一些数据的回收工作
    - 资源回收
  - 挂起态--七状态
    - 调节负载
    - 进程不占内存空间，进程映像在磁盘
- 进程队列
  - 为每一类进程建立一个或多个队列
  - 队列元素为PCB
  - 伴随进程的状态改变，其PCB从一个队列进入另一个队列

### 进程控制

进程的转换，由特定的原语构成

进程的创建
* PCB，PID
* 地址空间
* 初始化PCB，设置默认值
* 设置队列指针

进程的撤销
* 收回资源
  * 文件，网络，内存
  * 收回PCB

进程阻塞

Unix---fork()，exec(), wait(), exit()

fork()
* 分配一个空闲的进程描述符
* pid
* 一次一页的方式复制父进程的地址空间
* 父进程处继承共享资源，如打开的文件等
* 将子进程的状态设置就绪，插入就绪队列
* 子进程返回标识0
* 父进程返回子进程PID
  * Linux采用写时复制技术，加快了创建的速度

进程的分类

- 系统进程
- 用户进程 
- 前台进程
- 后台进程

* CPU密集型进程
* I/O密集型进程



* 进程层次结构
* Uinx进程家族数:init为根
* Windows：地位相同



**进程与程序的区别**

* 进程能更准确的刻画并发，而程序不能
* 程序是静态的，进程是**动态**的
* 进程有**生命周期**，程序是相对长久的
* 一个程序对应多个进程
* 进程具有其他进程的功能

**进程地址空间**

* 每个进程有自己的独立空间--逻辑地址，虚拟地址

| 高地址 |      |         |        |        | 低地址 |
| ------ | ---- | ------- | ------ | ------ | ------ |
| 栈-->  |      | <--- 堆 | 数据段 | 代码段 |        |

**进程映像**

- 用户：进程地址空间（栈，堆，数据段，代码段，共享库）
- 寄存器：PC，PSW，指令寄存器（IR），栈，通用寄存器
- 内核
  - 静态部分：PCB及各种资源数据结构
  - 动态部分：内核栈

**上下文切换**

* CPU硬件状态从一个进程到另一个进程的过程
* 进程运行时，其硬件信息保存在CPU的寄存器上
* 不运行时，寄存器信息保存在进程控制块PCB中；CPU运行新的进程时，将PCB相关的值送人对应寄存器

### 线程

* 并发度更高
* 开销更小
  * 快速的创建
  * 共享更方便
* 性能
  * 多处理器

* 进程是两个基本属性：
  * 资源的拥有着 
  * CPU调度单位 ---> 线程继承了这一属性
* 线程是进程的一个运行实体，也称**轻量级进程**
* 线程的属性
  * 标识ID
  * 状态及状态转换 -> 需要提供一些操作
  * 不运行保存上下文
  * 自己的栈和栈指针
  * **共享所在进程的地址空间和其他资源**
* **线程的实现**
* 用户级线程
  * 用户空间建立线程库，提供一组管理线程的方法
  * 运行时系统（run-time）：完成线程的管理工作（操作、线程表）
  * 内核管理的还是进程，不知道线程的存在
  * 线程切换不需要内核态特权
  * 例子：UNIX
  * 速度快
  * pthread_*
    * create,exit,join,yield,attr_init,
  * 优点
    * 速度快，调度算法应用程序特定，用户级线程可运行在任何操作系统
  * 缺点：
    * 内核只将处理器分配给进程，同一个进程的两个线程不能同时运行于两个处理器
    * 大多数系统调用是阻塞的，由于内核阻塞进程，进程中所有线程被阻塞
* 核心级线程
  * 内核管理所有线程，提供系统提供的API
  * 内核维护线程和进程的上下文
  * 线程的切换需要内核权限
  * 调度单位
  * 例子：WINDOWS
* 混合模型
  * 线程创建在用户空间
  * 线程调度等在核心态完成
  * 例子，Solaris
* 可再入程序：
  * 可被多个进程同时调用
  * 纯代码的，即执行过程自身不改变
  * 调用它的进程应该是提供数据区



## CPU调度

### CPU调用的相关概念

* **CPU调度**：任务是控制，协调进程对CPU的竞争
  * 如果没有就绪进程，系统会安排一个idle进程
* 系统场景
  * n个进程就绪，等待CPU运行
  * M个CPU，M>=1
* CPU调度的三个问题
  * what，按什么原则选择下一个执行的进程；**调度算法**
  * when，何时选择，**调度时机**
    * 典型的事件：创建，唤醒，退出等
    * 进程正常终止 或 错误而终止
    * 新进程创建 或 一个等待进程变成了就绪态
    * 进程运行态进入阻塞态
    * 进程运行态变成了就绪态（时间片到）
  * how，怎么让选中的进程上CPU运行；**调度过程，上下文切换**
    * 新的进程，进程切换
    * 切换全局页目录加载一个**新的地址空间**
    * **切换内核栈和硬件上下文**，硬件上下文包括执行新进程的全部信息
  * ex
    * 进程A下，B上
    * 保存A的上下文（PC，PSW）
    * 新的状态和其他相关信息更新进程A的PCB
    * 进程A移至合适的队列（就绪，阻塞）
    * 进程B设置运行态
    * B的PCB恢复上下文
* 上下文切换的开销
  * 直接开销，内核完成切换所用的CPU时间
    * 保存和恢复寄存器
    * 切换地址空间
  * 间接开销
    * 高速缓存，缓冲区，TLB
* CPU调度算法的设计
  * 批处理 --> 多道处理 --> 批处理和分时混合 --> 个人计算机 -->网络服务器

|      | 用户角度                     | 系统角度                     |
| ---- | ---------------------------- | ---------------------------- |
| 性能 | 周转时间，响应时间，最后期限 | 吞吐量，CPU利用率            |
| 其他 | 可预测性                     | 公平性，强制优先级，平衡资源 |

* 指标
  * 吞吐量，单位时间完成的进程数目
  * 周转时间，进程提出到运行完成的时间
  * 响应时间，提出到第一次响应
  * CPU利用率，cpu有效工作的时间比例

### 设计调度算法的几个因素

- 进程的优先级
  - 静态，进程创建时指定，运行过程中不在改变
  - 动态，创建时指定，运行过程可以改变
- 就绪队列
  - 每一个优先级一个队列
  - 时间片用完降低优先级
- 抢占和非抢占
  - 可抢占，系统可以强行剥夺正在运行进程的CPU
  - 不可，除自身因素，不能被抢占
- IO密集型和CPU密集型
  - 频繁IO，**调度进程偏好**
  - 大量的CPU时间进行运算
- 时间片
  - 一个时间段
  - 考虑因素
    - 进程切换的开销
    - 对响应时间的要求
    - 就绪进程的个数
    - CPU能力
    - 进程的行为

### 批处理系统的调度算法

- 先来先服务（fcfs-Fisrt come first serve）
  - 进程就绪时间
  - 优缺点
    - 公平，实现简单
    - 长进程后面的短进程需要等很长时间，不利于用户体验

- 最短作业优先（SJF-shortest job First）
  - 最短完成时间的进程优先执行
  - 先完成短作业，改善周转时间
  - 得到最短的平均周转时间
  - 不公平，新的短任务源源不断，有的任务长时间不能响应-**饥饿**

- 最短剩余时间优先（SRTN-shortest remaining time next）
  - SJF抢占式版本

- 最高相应对比（HRRN-highest response Ratio Next）
  - 综合FCFS和SJF
  - 调度时，计算响应比R；之后选择R高的进程执行
  - 响应比R = 周转时间 / 处理时间
    - ​		= （处理时间 + 等待时间）/ 处理时间
    - ​        = 1 + （等待时间/处理时间）

### 交互式系统采用的调度算法

- 轮转调度
  - 进程时间片用完排到队列尾
  - 目标：改善短任务平均响应时间
  - 解决的思路：周期性切换，进程分配时间片，时钟中断->切换
  - 选择时间片
    - 太长：降级FCFS,延长某些进程的需要时间
    - 太短：进程切换浪费时间
  - 优缺点
    - 公平，有利于交互式计算，响应时间快
    - 进程切换，花费开销
    - RR对于不同大小的进程是有利的，相同的。。
    - IO密集型不公平，IO用不完时间片
      - 辅助队列
  - 一般经验，10ms-100ms

- 最高优先级调度
  - 选择优先级最高的进程运行
  - 前台高于后台、系统高于用户 IO偏好
  - 优先数决定优先级
  - 就绪队列按照优先级组织
  - 不公平，优先级低的进程饥饿
  - **优先级反转问题**
    - 低优先级进程持有高优先级进程需要的资源，低优先级等待高于高优先级执行
    - 系统错误，高优先级停滞不前，系统性能低
    - 解决方案：
      - 设置优先级上限
      - 优先级继承
      - 使用中断禁止 

- 多级反馈队列
  - 设置多个就绪队列，第一级优先级最高
  - 给不同就绪队列进程分配不同的时间片，第一级时间片短，优先级低的时间片长
  - 第一级队列空，第二级队列调度，以此类推
  - 时间片轮转调度
  - 时间片用完放弃CPU，进入下一级队列
  - 阻塞的进程等待事件完成时，？返回原先队列
  - 若允许抢占，。。。

- 最短进程优先

| 调度算法         | 抢占 | 吞吐量             | 响应时间     | 进程影响           | 开销     | 饥饿 |
| ---------------- | ---- | ------------------ | ------------ | ------------------ | -------- | ---- |
| FCFS             | 非   | 不强调             | 可能很慢     | 短进程不利；IO不利 | 最小     | 无   |
| RR（轮转）       | 抢占 | 时间片短，吞吐量低 | 短进程偏好   | 公平               | 最小     | 无   |
| SJF              | 非   | 高                 | 短进程偏好   | 长进程不利         | 可能较大 | 可能 |
| SRTN（剩余时间） | 抢占 | 高                 | 好的响应时间 | 长进程不利         | 可能较大 | 可能 |
| HRRN（响应比）   | 非   | 高                 | 好的响应时间 | 很好的平衡         | 可能较大 | 无   |
| FeedBack（多级） | 抢占 | 不强调             | 不强调       | IO偏好             | 可能较大 | 可能 |

* 多处理器调度算法
  * 选择进程执行，还要选择哪一个CPU执行
* 考虑多个CPU之间迁移的开销
  * 高速缓存，块表失效
  * 尽可能一个进程同一个CPU执行
* 负载均衡



### 典型操作系统调度

* Unix: 动态优先数算法
* 5.3 BSD 多级反馈队列
* Linux 抢占式调度
  * 2.6 CFS调度算法
* Windows 基于优先级的抢占式多任务调度
  * 调度单位线程
  * 基于动态优先级，抢占式调度
  * 就绪线程按优先级进入响应队列
  * 现在高优先级线程
  * 同一优先级时间片轮转
  * 多CPU系统允许多个线程并行 
  * 调度时机+
    * 线程优先级改变
    * 线程改变了亲和处理机集合
  * 时间配额
* Solaris 综合调度算法


###  同步互斥机制

* 并发所有问题的基础，也是OS的基础
* 进程的特征
  * 并发：进程的执行是间断性的；进程的相对执行速度不可预测
  * 共享：进程、线程之间的制约性
  * 不确定性：进程的执行结果与其执行的相对速度有关，是不确定的
* ex
  * 银行，ATM：T1，T2，账户5000元

```
//T1:
...
read(x)
if (x>=1000) then
	x:x-1000;
	write(x)
	...

//T2:
...
read(x)
if (x >= 2000) then
	x:x-2000;
	write(x)
	...
```

#### 进程互斥

- 竞争条件：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确 时序
- 进程互斥：由于各进程要求使用的共享资源，而这些资源需要排他性的使用，各进程之间竞争使用这些资源，----这一关系称进程互斥
- 临界资源：critical resource
  - 系统中某些资源一次只允许一个进程使用，称这些资源为临界资源或互斥资源或共享变量
- 临界区：各个进程对某个临界资源实施操作的代码段
  - A进程进入临界区，B进程也想进入，将被阻塞
- 临界区的使用原则
  - 没有进程在临界区时，想进入的可以进入
  - 不允许两个进程处于临界区
  - 临界区外运行的进程不得阻塞其他的进程进入临界区
  - 不得使进程无限制等待进入临界区
- **实现方案**
- 软件方案：Dekker解法，peterson解法
  - 软件解法1

```
P：
...
while (free);
// 在此暂停
free = true;
临界区
free = false;
...

-------------
Q:
...
while (free);
free = true;
临界区   // 再次暂停
free = false;
...
```

* P再次启动，冲突发生
* lock()原子操作，unlock()

```
//软件解法2
P:
... while (not turn);
		临界区
	turn = false;
	...
Q:
	...
	while{} (turn);
		临界区
	turn = ture;
```

* 死锁

```
//软件解法3
P:
...
pturn = true;
while (qturn);
	临界区
pturn = false;
Q:
...
qturn = true;
while (pturn);
	临界区
qturn = false;

p into: pturn ^ not qturn
q : not pturn ^ qturn
//After you 问题
```

```
//软件解法4--- DEKKER算法
//引入一个turn枚举值，遇到After you问题让turn决定
P:
...
pturn = true;
while (qturn){
	if (turn == 2){
		pturn = false;
		while (turn == 2);
		pturn = true;
		}
}
	临界区
	turn = 2;
	pturn = false;
P:
...
pturn = true;
while (pturn){
	if (turn == 1){
		qturn = false;
		while (turn == 1);
		qturn = true;
		}
}
	turn = 1;
	Qturn = false;

```

```c
//软件解法5--peterson算法
进程i:
...
	enter_region();
		临界区
	leave_region();

#define False 0
#define True 1
#define N 2 //进程的个数
int turn; // 轮到那个进程
int intersted[n]; // 兴趣数组，初始化为False

void enter_region(int process)
{
	int other;
	other = 1 - process;
	intersted[process] = True;//表明感兴趣
	turn = process;//设置标志位
	while (turn==process && insterested[other] == True);
}
void leave_region(int process)
{
    interested[process] = False;
}
```

* 硬件方案：屏蔽中断，TSL(XCHG)指令
* 开关中断指令

```
关中断指令
	临界区
开中断指令
```

* 简单，高效
* 代价高，限制CPU并发能力（临界区大小）
* 不适用多处理器
* 适用OS本身，用户不能直接使用

```
TSL指令 测试并加锁
enter_region:
	TSL R,Lock
	CMP R, 0x0h
	JNE enter_region
	RET
		
leave_region:
	MOVE Lock, 0x0h
	RET
```

```
XCHG指令
enter_region:
    Move R, 0x1h  #寄存器置1
    XCHG R, LOCK
    CMP R, 0
    JNE	 enter_region
    RET
leave_region:
	Move Lock, 0
	RET
```

#### 进程同步

* 多个进程之间的协作关系
* 多个进程中发生的时间存在某种时序关系，需要相互合作，共同完成一项任务
* 生产者/消费者问题
  * 一个或多个生产者生产某种类型的数据放入缓冲区
  * 消费者取数据，每次一项
  * 只能一个生产者或消费者对缓冲区进行操作
  * 解决的问题
  * 缓冲区满，生产者不会继续向Buffer填充数据
  * 缓冲区空，消费者不会移走数据 
  * 避免忙等待：睡眠和唤醒（原子操作）

```c
#define N 100
int count = 0;
void producer(void)
{
	int item;
	while (True)
	{
		item = prodice_item();
		if (count == N) sleep();
		insert_item(item);
		count = count + 1;
		if (count == 1)
			wakeup(consumer);
	}
}
void consumer(void)
{
    int item;
    while (True)
    {
        if (count == 0) sleep();
        item = remove_item();
        count = count -1;
        if (count == N - 1)
            wakeup(producer);
        consume_item(item);
    }
}
```



* spooling: 输入程序和作业调度；作业控制进程和输出程序

#### 信号量及PV

* 特殊的变量
* 进程间传递信息的一个int
* 定义如下

```c
struct semaphore
{
	int  count;
	queueType queue;
}
```

* 信号量，初始化，P，V

```
P(s)
{
	s.count--;
	if (s.count < 0)
	{
		该进程设置阻塞状态;
		该进程插入相应的等待队列s.queue末尾;
		重新调度;
	}
}
V()
{
	s.count--;
	if (s.count <= 0)
	{
		唤醒s.queue中等待的一个进程
		改变其状态为就绪态，插入就绪队列
	}
}
```

* pv操作解决进程间互斥问题
  * 分析并发进程关键活动，划定临界区
  * 设置信号量mutex，初值1
  * 在临界区前实施p(mutex)
  * 临界区后实现v(mutex)

#### 经典的IPC问题

* 生产者消费者问题

```c
#define N 100 //缓冲区大小
tpyedef int semaphore; //信号量类型
semaphore mutex = 1;
semaphore empty =N;
semaphore full = 0;
void producer(void)
{
	int item;
	while (True){
		item = produce_item();
		p(&empty);
		p(&mutex);
		insert_item(item);
		v(&mutex);
		v(&full);
	}
}
void consumer(void)
{
	int item;
	while (True){
		p(&full);
		p(&mutex);
		item = remove_item;
		v(&mutex);
		v(&empty);
		consume_item(item);
	}
}
```

* p操作不可以调换，v操作可以

* 读者写者问题

  * 读者进程，只读数据区中的数据
  * 写者进程，只往数据区写数据
  * 条件
  * 允许多个读者同时执行读操作
  * 不允许多个读者同时写操作
  * 不允许读者、写者同时操作

* 第一类，读者优先

* 如果读者执行：

  * 无其他读者，写者，读者可以读
  * 若已有写者等，但有其他读者正在读，该读者也可以读
  * 若写者正在写，读者必须等

* 写者执行

  * 无其他读者、写者，可以写
  * 若有读者读，写者等待
  * 若其他写者正在写，写者等

```c
//第一个读者P，最后一个读者v
void reader(void)
{
	while (true)
    {
    	p(mutex);
        rc = rc + 1;
        if (rc == 1) p(w);
            read
        rc = rc -1;
        if (rc == 0) v(w);
        v(mutex);
	}
}
```



### 管程

* 为什么出现管程？ 信号量具有一些缺点，程序编写难，易出错
* 定义：
  * 是一个特殊的模块
  * 有一个名字
  * 共享资源的数据结构及在其上的一组过程
* 进程VS管程
  * 进程调用管程的过程间接访问管程中的数据结构
* 管程要保证什么
  * 互斥：管程是互斥进入的，**管程的互斥性是由编译器负载保证的**
  * 同步：设置条件变量及等待、唤醒操作解决同步问题
* 管程遇到的问题，多个进程在管程中出现
  * P等待q执行(前面进的等待，后面的继续执行) Hoare
  * Q等待P继续执行 Mesa
  * 规定唤醒操作为管程最后一个可执行的操作 Hansen

#### HOARE管程

* 资源，过程，条件变量队列，入口等待队列，紧急等待队列
* 管程是互斥的，所以当一个进程试图进入已占用的管程时，应当在管程的入口等待
  * 为此，管程的入口处设置一个 **入口等待队列**
* P唤醒Q，则P等待Q执行；Q唤醒R，R执行；如此，在管程内部可能出现多个等待队列
  * 管程内部设置一个紧急进程等待队列，称**紧急等待队列**，优先级要高于入口
* 条件变量的实现
  * 管程内部说明和使用的一种特殊类型的变量
  * 对于条件变量，可以执行wait和signal操作
* 管程的应用
* 管程实现的两个主要途径
  * 直接构造 -- 效率高
  * 间接构造 -- 信号量及PV等构造
* 管程解决生产者消费者问题

```pascal
procedure producer;
begin
	while true do
		begin
		
		item = produce_item;
		ProducerConsumer.insret();
	end
end

procedure consumer;
begin
	while true do
	begin
		item = PriducerConsumer.remove();
		consume_item(item);

	end
end

monitor producerConsumer
	condition full, empty;
	int count;
	
	procedure insert (item: int)
	begin
		if count == N then wait(full);
		insert_item(item);
		count++;
	end;
	
	fuction remove: int;
	begin
		if count == 0 then wait(empty);
		remove = remove_item; count--;
		if count == N - 1 then signal(full);
	end
	
	count = 0;
end monitor;
```

#### MESA 管程

* Hoare管程的一个缺点
  * 两次额外的进程切换
* 解决：
  * signal -- notify
  * notify：当一个正在管程中的进程执行notify时，它使x条件队列得到通知，发信号的进程继续执行
  * notify的结果，位于条件队列头的进程在将来的时候且处理器可用时恢复执行
    * 由于不能保证它之前没有其他进程进入管程，因而这个进程必须重新检查条件；while循环
    * 导致多一个额外的检测（但是不会有额外的进程切换）
  * 对notify改进
    * 给每一个条件原语关联一个监视计时器，等到一定的时间自动
    * 再次调度，再次检查条件
  * broadcast：该条件等待的进程全部释放进入就绪队列

**管程总结**

* 抽象数据类型：有一个明确的操作集合，通过它且只要通过他才能操纵该数据类型的实例
* 管程只能通过管程的某个过程才能访问资源
* 互斥的，某个时刻只能有一个进程或线程调用管程的过程
* 条件变量：提供进程与其他进程通信或同步而引入的
  * wait signal

#### 线程同步

互斥量

* pthread_mutex_init
* pthread_mutex_lock
* pthread_mutex_unlock

条件变量

- pthread_cond_init
- pthread_cond_wait:解锁，等待，上锁
- pthread_cond_signal 

#### 进程间通信

* 引入：信号量及管程的不足；不适用多处理器
* 进程通信
  * 消息传递：send receive原语
* 消息传递
  * 操作系统辅助完成
  * 操作系统空间一组缓冲区
  * 消息头（类型，接收进程ID。发送PID，消息长度，控制信息）；消息体
  * send -- 陷入内核 -- 复制消息 -- 消息入队 -- 复制消息 -- receive
* 共享内存
  * 物理内存建立一个物理内存空间 --- 两个进程的地址空间分别映射
  * 读者写者问题 -- 互斥问题
* 管道
  * 利用一个缓冲传输介质 -- 内存或文件连接两个进程的相互的通信
  * 字符流方式写入读出
  * 先进先出顺序
  * 管道通信必须提供的协调能力
* 套接字
* 远程库调用

#### Linux IPC

* Unix IPC、AT&T System V IPC、BSD
* 原子操作
* 自旋锁 读写自旋锁
* 信号量 读写信号量 互斥体
* 完成变量 顺序锁 屏障

```c
atomic_t v = atomic_init(0);
```

* 屏障
* 一种同步机制
* 对一组线程进行协调
* 应用场景：一组线程协同完成一项任务，需要所有的线程达到一个汇合点后一起推进



## 存储模型

### 地址从定向

* 程序加载到内存才能运行，程序保存在磁盘
* 多道程序设计模型--多个程序同时进入内存
* 每个进程有自己的地址空间
  * 进程不能访问其他进程的地址空间



* 进程的地址不是最终的物理地址
* 进程运行前无法计算物理地址
  * 不确定加载到内存的什么地方
* 需要地址重定位的支持
* **地址重定位**
* 逻辑地址（相对地址，虚拟地址）：经编译和汇编，首地址0，其他地址基于首地址
* 物理地址：内存的地址，可直接寻址
* f（逻辑地址） -- 物理地址，地址重定位
* 静态和动态
* 静态：当用户加载到内存时，一次性实现的逻辑--物理；一般软件完成
* 动态：进程执行过程中进行；需要硬件的支持



### 空闲的内存管理

* 等长划分、不等长划分
* 数据结构
  * 位图、空闲区表、已分配表、空闲区链表
* 内存分配算法
* 首次适配：在空闲表找到第一个满足进程的空闲区
* 下次适配：上次找到空闲区处接着找
* 最佳适配：查找整个空闲区，找到最小的
* 最差适配：满足进程最大的空闲区
* 找到空闲区后，空闲区分两部分，一部分进程使用，一部分新的空闲区



* 回收算法
* 内存回收算法
  * 当一块归还后，前后空闲空间合并，修改空闲区表
  * 四种情况，上相邻，下，上下，上下都不相邻

### 伙伴系统

* 一种经典的内存分配方案
* 主要思想：内存按2的幂进行划分，组成若干空闲块链表；查找该链表能满足进程需求的最佳匹配块
* 算法
  * 整个空间算一块：2^u
  * 假设进程申请大小S的块，如果满足2^u-1<s<=2^u，分配整个块
  * 否则分成大小相同的伙伴，大小为2^u-1
  * 一直划分下去直到产生大于或等于S的空间
  * ex:
    * 1m -- 2 * 512k -- 2 * 128k 

### 基本的内存管理方案

* 内存装载单位，进程
* **单一连续区**：一段时间只有一个进程，简单，内存利用率低
* **固定分区**：
  * 内存空间分割若干区域，称**分区**
  * 分区大小可相同也可以不同
  * 分区大小固定不变
  * 分区只能装1个进程
* 可变分区
  * 根据进程的需要，把空闲的空间风格出一个分区，分配给改进程
  * 剩余部分成为新的空间
  * 洞，外碎片导致内存利用率下降
* 碎片问题
* 碎片：很小，不易利用的空闲区，导致内存利用率下降
  * 解决方案，紧缩技术：在内存移动程序，小的合并成大的
  * 考虑的问题：系统的开销，移动的时机 
* 页式
  * 设计思想：进程地址空间被划分为相等的部分，称页
  * 内存空间按同样的大小划分相等的区域，称页框
  * 内存的分配规则：页为单位分配，按进程的需求分配，逻辑上相邻的，物理上不一定相邻；
  * 典型：4k或4m
  * 逻辑地址：页号+页内地址
  * 页表：
    * 页表项：记录了逻辑页号与页框的对应关系
    * 进程页表，放在内存
    * 地址转换，CPU取到逻辑地址，自动划分页号和业内地址；查页表得到页框号，在与偏移得到物理地址
* 段式
  * 设计思想：按程序自身的逻辑关系划分为若干个程序段，每个程序段有一个段名
  * 每个段由段号和长度确定
  * 段号+段内地址；显式给回
    * 段表：记录起始地址；段号+段首地址+段长度
    * 段表放在内存
* 段页式
  * 综合了页式+段式
  * 划分成段，每一段再按页面划分
  * 段表；页表；一个进程一张段表，多张页表

### 交换技术

- 内存不足时
- 内存扩充技术
  - 内存紧缩技术（可变分区）
  - 覆盖技术
  - 交换技术
  - 虚拟储存技术
- 覆盖技术
  - 程序的大小超过了物理内存的总和、
  - 程序执行不同部分在内存中相互替代
    - 按照自身的逻辑结构，将那些不会同时执行的程序共享同一块内存区域
    - 要求程序各模块之间明确的调用结构
  - 程序员申明覆盖结构，操作系统完成自动覆盖
  - 缺点：对用户不透明，复杂
- 交换技术
  - 内存空间紧张时，系统将内存的某些进程转到外存
- 交换区
  - 一般会指定一块特殊的磁盘区域，包含连续的通道，操作系统可以使用底层的磁盘读写高效访问
  - 何时？ 只要不用；内存不足
- 进程空间增长解决？
  - 栈向下增长，堆向上

 

## 虚拟存储技术

* 当进程运行时，先将其一部分装入内存，另一部分暂存磁盘，当执行指令或数据不在内存时，由操作系统自动完成从磁盘的调度
* 虚拟地址空间即分配给进程的虚拟内存
* 虚拟地址是虚拟内存中指令和数据的位置，该位置可以被访问
* 存储层次结构：R -- cache L1 -- L2 -- L3 -- RAM -- DISK
* 虚存：内存和磁盘有机结合。从而得到一个容量很大的内存
* 虚存是内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用
  * 提供了一个比物理内存大很多的地址空间；与磁盘容量的可用空间和寻址机制有关
* 地址保护
  * 确保每个进程有独立的地址空间
  * 确保进程访问合法的地址范围
  * 确保进程的操作是合法的，权限
* 虚拟页式
  * 虚拟存储技术  + 页式存储管理方案 -- 虚拟页式存储管理系统
  * 基本思想：
  * 进程运行前，不是装入全部页面，而是装入一个或0各
  * 之后，根据运行的需要，动态装入其他页面
  * 内存满，而又需要新的页面装入 --- 置换算法
  * 两种方法：请求调页， 预先调页（猜测）
  * CPU时间和磁盘空间结合起来，换取昂贵内存空间 --- 资源转换技术

### 页表及页表设计

-  页表由页表项组成
- 页框号、有效位（内存或磁盘）、访问位（引用位），修改位（修改了），保护位（读、写）
- 页表（32bit 虚存）
  - 页面大小4k；页表项为4字节
    - 进程 2^20页， 页表页 1024
  - 64bit
  - 页面大小4k;页表项大小8字节
- 页目录--多级页表
- 引入反转页表
  - 从虚拟地址空间出发：虚拟地址 -- 查页表 -- 页框号 -- 形成物理地址
  - 每一个进程一张页表
  - 解决思路
  - 从物理地址空间出发，系统建立一张页表
  - 页表项记录进程i的某虚拟地址与页框号的映射关系

### 快表（TLB）

* 内存管理单元（虚拟地址 -- 物理地址）
* 页表 -- 两次及以上的内存访问程序的局部性原理 --- 引入快表（Translation Look-aside Buffers）
  * 高速缓存
  * 随机存储组成，连线的寻址机制，接线逻辑，按特地的匹配标志一个存储周期同时进行比较
  * 相连存储器：按内容并行查找
  * 保存真正运行进程的页表的子集
  * --- 加快地址转换的速度

### 页错误

* 地址转换的过程硬件产生的异常
* 具体原因：
  * 虚拟页面没有调入物理内存 -- 缺页异常
  * 页面违反权限 -- 读写，用户内核
  * 错误的访问地址
* 缺页异常处理 
  * 硬件发现不在内存-- 产生缺页异常
  * 操作系统执行缺页异常处理程序：获取磁盘地址，启动磁盘，调入内存
    * 内存有足够的空闲
    * 无空闲 -- 置换，如果被修改过，写入磁盘

### 软件的相关策略

* 驻留集 -- 每个进程分配单数页框
* 固定分配策略
  * 进程创建时确定
  * 可根据进程类型（交互，批处理，应用类）或基于程序员或管理员确定
* 可变分配的策略
  * 根据缺页率评估
  * 系统开销
* 置换问题
  * 范围：
    * 局部，本次进程的主流集
    * 全局,内存所有为锁定的页框
  * 置换策略
    * 决定置换当前内存中的哪一个页框
    * 决策的目标 -- 最不可能访问的页
    * 局部性原理，基于过去的行为预测将来的行为
    * 越精细越复杂，系统开销大
  * 页面锁定
    * 为什么锁：采用虚存后，使进程的运行时间变得不稳定
    * 页框增加一个锁定为
    * 不让锁定的页面换出内存，避免交换过程带来的不确定延迟
    * 操作系统的核心代码，关键的数据结构，正在IO的页面
  * 清楚策略
    * 从进程的驻留集收回页框
    * 虚拟页式系统工作的最佳状态，发生缺页异常时，系统有足够的空闲页框
    * 结论：在系统中保存一定数目调度空闲页框比所有内存并在需要时搜索一个页框有更好的性能
    * 设计一个分页守护进程，多数随机睡眠，定期唤醒检查
    * 空闲页框过少，分页守护进程通过预先设定置换算法，换出内存
    * 如果转入进程修改，还需写回磁盘
    * 当进程需要使用一个已经置换的页框时，如果该页框还没有被新的内容覆盖，则他从空闲页框集合移出即可恢复
    * 页缓冲技术

### 置换算法

* 最佳页面置换算法（OPT）-- 置换以后不在需要或最远的将来才会用到的页面
  * 不能实现
  * 作为一种标准-- 衡量其他算法的性能
* 先进先出（FIFO）
  * 选择内存中**驻留时间最长**的页并置换
    - 超市撤换商品
    - 页面链表伐
* 第二次机会算法（SCR):按照先进先出选择某一页面，检查其访问位R，如果0，则置换；如果为1，则给他第二次机会，将访问位置0
* 时钟算法，第二次机会算法改进，循环列表，比摘链挂链块
* 最近未使用算法（NRU）（not recent used）
  * 选择**最近一段时间未使用**过的一页并置换
  * 实现，访问位（R）,修改位（M）--R位定期清0
  * 查看RM
    * 1：无访问，无修改
    * 2：无访问，有修改
    * 3：有访问，无修改
    * 4：有访问，有修改
    * 随机从编号最小的非空类选择一页置换
  * 时钟实现
* 最近最少使用算法
  * 选择最后一次访问时间距离当前时间最长的一页并置换
  * 未使用的时间最长
  * 最接近OPT，开销大
* 最不经常使用算法（NFU）
  * 选择**访问次数最少**的页面置换算法
  * LRU的一种软件解决方案
  * 实现：软件计数器，一页一个，初值0，每次时钟中断，计时器+r；发生缺页中断，选择计数器值最小的一页置换
* 老化算法
  * 模拟LRU：计数器+R前先右移一位（除2），R位先加到计数器最左端
* 页面置换算法的应用
* BELADY现象
  * 分配页面数目增加，缺页次数反而增加

### 影响缺页次数的因素

* 页面置换算法
* 页面本身的大小
  * 页面大小对分页硬件设计非常重要，而对操作系统可选参数、
  * 考虑的因素
    * 内部碎片
    * 页表长度
    * 辅存的物理特性
* 程序的编制方法
  * 一个页框 -- 128 int，矩阵 128x128
  * 行存储，列存储
* 分配进程的页框
  * 越多缺页率越低
* 工作集模型
  * 基本思想：程序的局部性原理，一般情况下，进程一段时间内总是集中访问一些页面，这些页面称**活跃页面**，如果分配给一个进程的物理页面太长，导致进程所需的活越页面不能全部装入内存，则导致运行过程中频繁发生中断
  * 工作集：一个进程当前正在使用的页框集合
    * 进程在过去的n个时间虚拟时间访问到页面的时间集合
  * 取决于：
    * 该页序列特性
    * 时刻t
    * 工作集窗口长度
* 工作集算法
  * 基本思路：找出一个不在工作集中的页面并置换
  * 思路
    * 每个页表一个字段，记录该页面最后一次被访问的时间
    * 设置时间值T
    * 判断，T和页面访问时间，在内还是外
* 内存映射文件
* 基本思想：通过mmap将一个问题映射到虚存的地址空间，访问这个文件就像访问内存大大数组，而不是对文件读写
  * 访问的时候才读入文件
  * 进程退出时，解除映射或保存文件
* 写时复制技术



## 文件系统

### 文件和文件系统

* 文件是对磁盘的抽象
* 所谓文件是指一组带标识（标识为文件名）的，在逻辑上有完整意义的**信息项序列**
* 信息项序列：构成文件内容的基本单位（单字节或多字节）、各信息项有顺序关系
* 文件内容的意义：由文件建立者和使用者解释
* 如何设计 一个文件系统？
* 用户角度
  * 文件的组织
  * 文件的命名
  * 文件的保护
  * 可用实施的操作
* 操作系统角度
  * 文件的描述和分类
  * 文件目录的实现
  * 存储空间的管理
  * 文件的物理地址
  * 磁盘实际运作方式（与设备管理的接口）
  * 文件系统的性能
* 文件系统
  * 操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用
  * 主要的任务
  * 统一管理磁盘空间，实现磁盘空间的分配与回收
  * 实现文件的按名存取； 名字空间 -- 磁盘空间
  * 文件信息的共享，并提供文件的保护，保密手段
  * 有一个方便使用，易于维护的接口，并向用户提供相关的统计信息
  * 提高文件系统的性能
  * 提供与IO系统的统一接口
* 文件的分类
  * 普通文件：包含了用户信息，一般为ASCII或二进制文件
  * 目录文件：管理文件系统的系统文件
  * 特殊文件（设备文件）：字符设备（模仿串行IO设备），块设备（模拟磁盘）
  * 管道文件
  * 套接字
* 文件的逻辑结构
  * 用户角度看文件，或用户的访问方式确定
  * 流式文件：构成文件的基本单位是字符
    * 文件是有逻辑意义，无结构的一串字符的集合
  * 纪录式文件：文件由若干个记录组成，可用按记录进行读写查找等操作
    * 每条记录由其内部结构
  * 文件存取
    * 顺序存取
    * 随机存取：提供读写的位置 （seek）

### 文件的存储介质

* 磁盘，SSD，光盘，磁带，U盘
* 物理块（块block，簇cluster） 
  * 信息存储、传输、分配的独立单位
  * 存储设备划分为大小相等的物理块，统一编号
* 一块磁盘 -- 多个盘面（读写磁头） --  磁道（盘面的同心圆）--  扇区
  * 任何时刻只有一个磁头活动状态；输入输出数据流以**位串形式**出现
  * 物理地址形式：磁头号（盘面号），磁道号（柱面号），扇区号
* 磁盘的访问，
  * 读、写操作；磁盘的地址（设备号，柱面号，磁头号，扇区号），内存地址（源和目的）
  * 完成过程的三个动作
    * 寻道
    * 旋转延迟
    * 数据传输

### 磁盘空间的管理

- 位图：二进制位反应一块或簇
- 空闲块表，所有的空闲块记录在一个表中即空闲快表
  - 主要两项内容：起始块号，块数
- 空闲链表：空闲块组成一个链
  - 成组链接法

### 文件属性

* 文件控制块：为管理文件而设置的数据结构，保存管理文件所需的所有有关信息（文件属性或元数据 -- 数据的数据）
* 文件名，文件号，文件大小，文件地址，创建时间，最后修改时间，最后访问数据，保护，口令，创建者，当前拥有者，文件类型，共享计数，各种标准（只读，隐藏，系统，归档，ASCII，二进制，顺序，随机，临时文件，锁）
* 文件操作：create,  delete, open, close , read ,write, append,seek
* 文件目录，目录项与目录文件
  * 统一管理每个文件的元数据，以支持文件名到文件物理地址的转换
  * 将所有文件的管理信息组织在一起，即构成文件目录
* 目录文件
  * 将文件目录以文件的形式存放在磁盘上
* 目录项
  * 构成文件目录的基本单元
  * 目录项可以是FCB，目录是文件控制块的有序集合
* 路径名
  * 绝对路径
  * 相对路径
  * 当前目录、工作目录

### 文件的物理结构

* 文件在存储介质上存放方式
* 解决的两个问题
  * 划分N块，N块怎么存放
  * 其地址在FCB怎么记录
* 连续结构（顺序结构）
  * 文件的信息存放在若干连续的物理块中
  * 优点：
    * 简单
    * 支持顺序和随机存取
    * 所需的磁盘寻道次数和寻道时间最少
    * 同时读入多个块，检索一个块也很容易
  * 缺点
    * 文件不能动态增长
    * 不利于文件的插入和删除
    * 外部碎片
* 链接结构
  * 不连续的物理块，通过指针链接
  * 如何记录？ FCB记录文件首地址即可
  * 优缺点
    * 提高磁盘空间的利用率，不存在外部碎片问题
    * 有利于文件的插入和删除
    * 有利于文件的扩充
    * 缺点
    * 存取速度慢，不能随机存取
    * 可靠性问题，指针出错
    * 更多的寻道次数和寻道时间
    * 链接指针占用一点的空间
* 一个变形，FAT；集中存放文件分配表 -- 即FAT表
* 索引结构
  * 存放在不连续的物理块中
  * 系统建立了 -- 索引表
  * 索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块
  * 优缺点
  * 顺序，随机都可
  * 满足了文件的动态增长，插入删除要求
  * 充分利用磁盘
  * 缺点
  * 较多的寻道次数和寻道时间
  * 索引表本身的系统开销 -- 内存，磁盘空间，存取时间
* 索引表的组织
  * 链接方式，多级索引，综合模式
* UNIX的三级索引结构--- ex2
  * 主索引表15个索引项，每个2字节
  * 前12个直接存放文件的物理块号（直接寻转）
  * 如果文件大于12块，利用第13项指向第一个物理块
  * 14项二级，15项3级

### 文件系统的实现

* 磁盘上与内存中的布局
* 磁盘上
  * 如何启动操作系统
  * 磁盘如何管理？获取磁盘的相关信息
  * 目录文件在磁盘上怎么存放？普通文件在磁盘上怎么存放
* 内存中
  * 进程使用文件，操作系统如何支持，文件系统的内存数据结构

* 磁盘分区：物理磁盘划分几个相互独立的部分，称分区
* 文件卷：磁盘上的逻辑分区，由一个或多个物理块组成
  * 可以是一个磁盘，可以是部分磁盘，或跨盘（RAID）
  * 同一个卷使用一份数据结构管理
  * 一个文件卷上，文件系统信息，一组文件，未分配空间
  * 单位：块 或者 簇
* 格式化：在一个文件卷上建立文件系统，即建立并初始化用于文件分配和磁盘空闲空间管理的管理数据
* 磁盘上的内容
  * 引导区：引导操作系统，通常第一个扇区
  * 卷信息
  * 目录文件
  * 用户文件
* 文件目录检索 -- 两步骤
  * 目录检索： 用户给出的文件名 -- 按文件名查找到FCB
  * 文件寻址：根据FCB信息，计算文件中任意记录或字符在存储介质上的地址
* 加快目录检索
  * 一种：目录分解法 -- FCB分成两部分
    * 符号目录项
    * 基本目录项
* UNIX文件系统
  * FCB=目录项+i结点
  * 目录项：文件名+i结点号
  * 目录文件由目录项组成
  * i结点：描述文件的相关信息
  * 每个文件由一个目录项，一个i结点，若干磁盘块组成
  *  

### 文件系统FAT

* windows FAT16
* 簇大小：1，2，4，8，16，64扇区
* 文件的数据记录在引导扇区
* FAT表现：2字节
* 目录项：32字节
* 根目录大小固定
* MBR
  * 主引导扇区-0号扇区
* DBR
* 文件分配表
  * 状态：未使用，坏簇，系统保留，文件占用

### 文件操作的实现

* 创建文件：建立系统与文件的联系，建立FCB
  * 创建目录项
  * 分配存储空间
* 打开文件
  * 根据文件名在文件目录中检索，并将该文件的目录读入内存，建立相应的数据结构，为后续文件操作做好准备
  * 返回一个文件描述符或者文件句柄
* create(文件名，访问权限)
  * 检查参数的合法性
    * 命名，重复文件
  * 申请空闲目录项，填写相关内容
  * 申请磁盘块
  * 返回
* seek(fd, 新指针的位置)

### 文件系统的管理

* 可靠性：抵御和预防物理性和人为性破坏的能力
* 坏块问题
* 备份：通过转储操作，形成文件或文件系统的备份
* 系统备份
  * 全量转储
  * 增量转储
  * 物理转储：磁盘块--对磁盘块
  * 逻辑转储
* 文件系统一致性
  * 磁盘 -- 内存 -- 写入磁盘
  * 若写回，系统崩溃，则文件系统出现不一致
  * 解决方案：设置一个实用程序，系统重启时，运行程序，检查磁盘块和目录系统
* 磁盘块的一致性检查
  * 表一：每块在文件中出现的次数
  * 表二：每块在空闲区的次数
* 文件系统的写入策略
  * 一致性和速度
  * 通写 -- write-through
  * 延迟写（lazy-write）：利用回写
  * 可恢复写
    * 采用事务日志
    * 即考虑安全性和速度 -- ntfs、ex3

### 文件系统的安全性

* 提供安全性，特定的操作系统机制
* 对拥有权限的用户，应该让其进行相应操作；否则禁止
* 防止其他用户冒充
* 访问控制
  * **访问控制表**
  * 每个文件一个
  * 记录用户的ID和访问权限
  * 用户可以是一组
  * 文件可以是一组文件
  * **能力表**
  * 每个用户一个
  * 记录文件名及访问权限
  * 用户可是一组
  * 文件可以是一组
* UNIX文件访问控制
  * 对访问者的识别
  * 文件主，同组，other

### 文件系统的性能

* 磁盘服务：速度成为系统性能的主要瓶颈；设计文件系统尽可能减少磁盘的访问次数
* 方法
* 块高速缓存
  * 又称 文件缓存，磁盘高速缓存，缓冲区高速缓存
  * 内存中为磁盘块设置的一个缓冲区，保存了磁盘某些块的副本
  * xx
  * 检查所有的读请求，看所需的块是否在高速缓存
  * 如果在，则直接读；否则，先将数据读入块高速缓存，再拷贝到所需的地方
  * 由于局部性原理，可能在将来的某个时间段再次访问到
* 实现
  * 块高速缓存组织
    * 双向链表，散列
  * 块高速缓存的置换（LRU) 
  * 块高速缓存的写入策略 -- 该块是否影响文件系统一致性
* 提前读取
  * 思路，每次访问磁盘，多读入一些磁盘块
  * 依据：局部性原理
  * 开销，较小
  * 有针对性
* windows的文件访问方式
  * 不使用文件缓存
    * 普通方式
    * 通过windows提供的FlushFileBuffer
  * 使用文件缓存
    * 预读取	，每次读取块大小，缓冲区大小，置换方式
    * 写回
  * 异步模式
    * 不再等待磁盘操作的完成
    * 处理器和IO并发的工作
  * Cache Manager

* 合理的分配磁盘空间
  * 分配磁盘块时，把可能顺序存取的块放一起
    * 尽可能分配再同一柱面，从而减少磁盘的移动次数和距离
* 磁盘调度
  * 当多个访盘请求等待时，采用一定的策略，对这些请求的服务顺序调整安排
    * 降低平均磁盘服务时间，达到公平、高效
    * 公平：一个IO请求有限的时间内满足
    * 高效：减少设备机械运动带来的时间开销
  * 先来先服务
    * 按访问请求到达的先后次序访问
    * 简单公平，效率不高
  * 最短寻道时间优先
    * 优先选择当前磁头最近的访问请求
    * 改善了平均访问时间；饥饿
  * 扫描算法
    * 有请求时，先按一个方向移动，判断该方向的请求
  * 单向扫描调度算法
    * 总是从0号向里扫描
    * 按柱面的位置选择访问者
    * 到最后一个柱面后，立即带动磁头返回0号柱面
    * 返回时不服务
    * 返回后再次扫描
  * N-Step-scan
    * 磁盘请求队列分成长队为N的子队列，每一次用一个scan处理
    * 处理某一队列时，新请求添加到其他子队列
    * 如果最后还剩一个队列，且请求小于N，则一起处理
    * N值较大，性能接近scan，N=1退化FIFO
    * 磁头臂的粘性
  * FSCAN
    * 两个子队列
    * 扫描开始时，所有请求都在一个队列，另一个队列为空
    * 扫描过程的其他请求，放入另一队列
    * 对清的请求服务延迟到所有的老请求之后
  * 旋转调度算法
    * 旋转调度：根据延迟时间来决定执行次序的调度
    * 三种情况
      * 同一磁头不同扇区
      * 不同磁头不同扇区
      * 不同磁头相同扇区
    * 解决
      * 前2中，先到达的读写磁头位置下的扇区传输
      * 第三种，随机选一个，其他的延迟一周
* 信息的优化分布
  * 记录再磁道的排列方式也会影响输入输出操作的时间
* 记录的成组与分解
  * 若干记录放一块
* RAID技术（独立磁盘冗余阵列）
  * 多块磁盘按照一定的要求构成一个独立的存储设备
  * 提高可靠性和性能
* 如何组织？
  * 基本思想：多个磁盘组织一起，作为一个逻辑卷提供磁盘跨越功能
  * 通过把数据分成多个数据块，并行的写入或读出多个磁盘，提高数据传输率
  * 通过镜像或校验操作，提供容错能力（冗余）
  * 最简单的：镜像
  * 最复杂：块交错检验

## IO系统

### IO管理简述

* IO性能经常成为系统性能的瓶颈
* 操作系统庞大复杂的原因之一
  * 资源多，杂，并发均来自IO
  * 速度差异很大
  * 应用
  * 控制接口的复杂性
  * 传送单位
  * 数据表示
  * 错误条件
* 与其他的功能联系紧密，特别是文件系统
* 设备的分类--按数据组织分
* 块设备
  * 以数据块为单位存储、传输信息
  * 传输的速率较高，可寻址（随机读写）
* 字符设备
  * 字符为单位存储，传输信息
  * 传输速率低，不可寻址
* 存储设备；传输设备；人机交互设备
* 设备的分类 -- 资源分配角度
  * 独占设备 -- 一段时间只能一个进程使用的设备，一般为低速IO
  * 共享设备 --  多个进程共同使用，交叉的方式使用，资源利用率高
  * 虚设备 -- 模拟其他设备；通常高速设备模拟低速
* IO管理的目标和任务
  * 按用户的请求，控制设备的各种操作，完成**IO与内存之间的数据交换**，最终完成用户的IO请求
  * 设备分配和回收
    * 记录设备的状态
    * 根据用户的请求和设备的类型，采用一定的分配算法，选择一条数据通路
  * 执行设备驱动程序，实现真正的IO操作
  * 设备中断处理：处理外部设备的中断
  * 缓冲区管理：管理IO缓冲区 -- 解决速度不匹配问题
* 建立方便、统一的独立于设备的接口
* 充分利用各种技术（通道，中断，缓冲，异步IO等）提高CPU与设备、设备与设备之间并行概念工作的能力，充分利用资源，提高资源利用率
  * 并行性
  * 均衡性（使设备充分忙碌）
* 保护 -- 安全的，不被破坏的

### IO硬件组成

* IO设备一般是机械和电子两部分组成
  * 机械是设备本身
  * 电子部分（设备控制器）
* 设备接口 -- 控制器的作用
  * 操作系统将命令写入控制器的接口寄存器，实现IO，并从接口寄存器读取状态信息和结果信息
  * 接收命令后，可独立CPU，命令结束后，产生一个中断
  * 控制器与设备之间的接口常是一个低价接口
  * 控制器的任务：把串行的位流转换为字节块，并进行必要的错误纠正
    * 首先，控制器按位进行组装，然后存入控制器内部的缓冲区中形成以字节为单位的块；检查无错误时，再将他复制到内存
* IO端口地址
  * 接口电路中的每个寄存器，具有独立的，唯一的地址，是个整数
  * 所有IO端口地址形成的IO端口空间
* IO指令和IO地址是相互关联的
  * 内存映像编址（内存映像IO模式）
    * 与内存统一编址
    * IO看为存储单位，对IO读写操作等同于内存操作
    * 优点，不需要IO指令；IO端口有较大的地址空间
    * 缺点，占用内存空间
  * IO独立编址（IO专用指令）
    * 完全独立，与内存无关
    * 专门的IO指令
    * 优点，外设不占内存地址空间；编程易于区分对内存还是IO
    * 缺点，IO端口操作的指令少，不灵活
* 内存映射IO的优缺点
  * 不需要特殊的保护机制阻止

### IO控制方式

* 可编程IO（轮询、查询）
  * 由CPU代表给进程发送IO命令，进程进入忙等待，直到操作完成才继续执行
* 中断驱动IO
* DMA

### IO软件设计

* 把IO软件组织成多个层次
* 每一层都依赖更底层的操作，从此隐藏细节；同时又想高层服务
* 较高层不依赖硬件，给用户一个友好的清晰的简单的功能更强的接口
*  
  * 用户级IO软件
  * 与设备无关的OS软件
  * 设备驱动程序
  * 中断处理程序
  * 硬件
* 设备无关
  * 用户编写的程序可以访问任意的IO设备，无需事先指定设备

### IO相关技术

- 缓冲技术
  - 解决CPU与IO之间的速度不匹配
  - 提高CPU与IO并行性
  - 减少IO设备对CPU的访问次数
- 缓冲区分类
  - 硬缓冲：硬件寄存器
  - 软缓冲：内存中
  - 缓冲区管理
    - 单缓冲
    - 双缓冲
    - 缓冲池
- UNIX SYSTEM V缓冲技术
  - 采用缓冲池技术，可平滑和加快信息在内存和磁盘之间的传输
  - 缓冲区结合提前读和延迟写对具有重复性及阵发行IO进程，提高IO速度很有帮助
  - 充分利用之前从磁盘读入，虽已传入用户区但仍在缓冲区的数据
- 实现
- 缓冲池：200个缓冲区（512 or 1024）
- 缓冲首部+缓冲区数据区
- 空闲缓冲队列
- 设备缓冲队列

### IO设备的管理

* 描述设备、控制器的表格
* 建立同类资源的队列
* 面向进程IO请求的动态数据结构
* 建立IO队列
* 独占设备的分配
* 共享设备 -- 分时式

### IO性能问题

* 使用CPU利用率尽可能不被IO降低
* CPU尽可能摆脱IO
  * 减少或缓解速度差距 -- 缓冲技术
  * 使CPU不等待IO 异步IO
  * 摆脱CPU DMA，通道
* 同步IO，异步IO

## 死锁

### 基本概念

* 一组进程中，每个进程都**无限等待**该组进程中另一进程占用的资源，因此无法得到资源，称**死锁**
* 死锁发生，会浪费大量的资源，可能导致系统崩溃
  * 参与死锁的所有进程都在等待资源
  * 参与死锁的进程是当前系统中所有进程的子集
* 死锁出现的原因
  * 资源数量的有限、锁、信号量错误的使用
* 资源的使用方式 -- **申请--分配--使用--释放**
* 可重用资源：可被多个进程多次使用
  * 可抢占资源与不可抢占资源
  * 处理器，内存，IO
* 可消耗资源：只使用一次、可创建和销毁的资源
  * 信号
* 活锁和饥饿
  * 活锁：先加锁；在轮询；无进展
* 死锁的必要条件
  * 互斥使用 -- 资源独占
  * 占有且等待 -- 进程在申请新的资源的同时保持对原有资源的等待
  * 不可抢占 -- 资源的申请者不能强行从资源的占用者中夺取资源，只能由占有者自愿释放
  * 循环等待
    * P1，2，3 ...
    * p1等p2；p2等p3 ...;pn等p1

### 资源分配图 

* 有向图描述系统资源和进程的状态
* 二元组 G = （V，E）
* 画图的说明
* 系统由若干类资源构成，一类资源称一个资源类；每个资源类包含若干个同类资源，称资源实例
* 死锁定理，
  * 如果资源分配图没有环路，则系统中没有出现死锁，如果图中存在环路，则可能出现死锁
  * 如果资源类只包含一个资源实例，则环路是死锁存在的充分必要条件

- 资源分配图化简
  - 化简步骤
  - 找一个非孤立，且只有分配边的进程结点；去掉分配边，将其变成孤立结点
  - 再把相应的资源分配给一个等待该资源进程，即将该进程的申请边变成分配边
  - 重复 前两步

### 解决死锁问题的方法

* 解决死锁的方法

* 不考虑此问题（鸵鸟算法）

* 不让死锁发生

  * 死锁预防
    * 静态策略：设计合适的资源分配算法，不让死锁发生
  * 死锁避免
    * 动态策略：以不让死锁发生为目标，跟踪资源分配过程，根据评估的结果决策是否分配

  * 让死锁发生
    * 死锁检测与解除

* 死锁预防：设计系统时，确定资源分配算法，排除发生死锁的可能性

  * 具体做法：破坏死锁发生的条件
  * 互斥使用、资源独占
    * 资源转换条件：独占的资源转为共享资源
  * 占有且等待
    * 要求每个进程在运行前，必须一次性申请他要求的所有资源
      * 资源利用率低，饥饿
    * 必须全部释放已占用的资源，在申请
  * 不可抢占
    * 当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源
    * 局限性：适用于状态易恢复
  * 循环等待
    * 通过定义资源类型的线性顺序实现
    * 方案：资源有序分配法
      * 资源编号，申请资源必须严格按照递增顺序进行
    * 哲学家就餐问题
      *   

* 死锁避免 

  * 在系统运行过程中，对进程发出的每一个系统能够满足的资源进行动态检测，并根据检查结果决定是否分配资源，若分配，发生死锁则不分配
  * 安全序列，对于序列的每一个进程Pi，他以后还需的资源量不超过系统当前剩余资源量与所有进程pj当前占用资源量之和
  * 安全状态一定没有死锁发生

* 银行家算法

  * 仿照银行发放贷款采取的控制方式
  * 一种死锁避免算法
  * 应用条件
  * 固定数量的进共享固定数量的资源
  * 预先指定完成工作所需的最大资源量
  * 进程不能申请比可用的资源总数还多的资源
  * 进程等待资源的时间是有限的
  * 如果系统满足了进程对资源的最大需求，那么进程应该在有限的时间内使用资源，然后归还

```c
// n进程, m资源
int available[m]; // 可以分配的资源
int Max[n,m]; //对每一类资源的最大需求
int Allocation[n,m]; //申请了的
int Need[n,m];//进程还需要多少资源
int request[n,m];//本次进程申请的资源

if request[i] <= Need[i]
    if requst[i] <= Availsble[i] wait()
    {
        Available = Avaliable - Request[i];
        Allocation[i] = Allocation[i] + request[i];
        Need[i] = Need[i] - request[i];
    }
```

* 安全性检查

```
int work[m];
int finish[n];

```

* 死锁的检测与解除
  * 允许死锁发生，但不断跟踪，判断死锁是否发生
  * 一旦发生，采取措施，解除
  * 检测时间
    * 进程由于资源请求不满足而等待时检测
      * 缺点：系统开销大
    * 定时检测
    * 系统资源利用率低时检测
* 一个简单的死锁检测算法
* 重点是最小代价恢复
  * 撤销所有的死锁进程
  * 进程回退在启动
  * 按照某种原则撤销死锁进程
  * 逐一的抢占资源

### 哲学家就餐问题


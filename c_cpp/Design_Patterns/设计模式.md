# 设计模式



- 目的： 耦合性，内聚性，可维护性，扩展性，重用性，灵活性
- https://www.bilibili.com/video/BV1G4411c7N4
- https://github.com/Waleon/DesignPatterns

## 七大原则

* 设计模式的依据

### 单一接口原则

- 对类来说，一个类只负责一项职责。
- 职责变化会影响到另一个原则
- 降低复杂度，提高可读性，可维护性
- 降低变更的风险
- 如果逻辑够简单，才可以违反单一原则；
- 如果类的方法足够少，可以在方法层面保持单一原则 

### 接口隔离原则

* interface Segregation
* 客户端不应该依赖它不需要的接口，即一个类对另一个依赖应该建立在最小接口上
* 将接口拆开，实现最小
* A通过Ifc1依赖B类，C通过ifc2依赖D，B和D都需要实现他们不需要的方法
* 将ifc1分成几个独立的接口，保持最小依赖

### 依赖倒转原则

* 高层模块不应该依赖低层模块，二者都应该依赖于抽象（接口，抽象类）
* 抽象不应该依赖于抽象，细节应该依赖于抽象
* 依赖倒转的中心思想是勉县接口编程
* 依赖倒转基于这个设计理念：相对细节的多变性，抽象的东西要稳定的多。已抽象为基础搭建的架构比细节为基础的架构稳定的多。在Java中，指的是接口或抽象类，细节是实现类 
* 使用接口和抽象类的目的是制定好规范，而不涉及具体的操作，把展现细节的任务交给他们的实现类去完成
* 三种传递方式
  * 接口传递
  * 构造方法传递
  * setter传递
* 注意事项
  * 低层模块尽量要有抽象类和接口，或者两者都有，程序稳定性更好
  * 变量的声明类型尽量是抽象类和接口，这样我们对变量的引用和实际对象间，又一个缓冲层
  * 继承时遵循里氏替换原则

### 里氏替换原则

* 继承包含这样一层含义：父类实现好的方法，实际上是设定规范和契约，虽然它不强求子类必须遵守，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏
* 继承在程序设计带来便利的同时， 也带来了弊端，比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑所有的子类，并且父类修改后，所有涉及到子类的功能都有可能发生故障
* 尽量遵循：里氏替换原则
  * 适当情况下，通过聚合，组合，依赖解决问题
* 实际中，重写父类方法，原有功能修改新的功能，写起来简单，复用性差，特别是多态频繁时
* 通常的做法是：原来的父类和子类都继承一个更通俗的类，原有的继承关系去掉，采用依赖组合聚合关系代替

### 开闭原则

* 编程最基础，重要的原则
* 类，模块和函数应该是对扩展开放的，对修改关闭的。用抽象构建框架，用实现扩展细节
* 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
* 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则
* 

### 迪米特原则

* 一个对象应该对其他对象保持最少的了解
* 类与类关系越密切，耦合度越大
* 最少知道原则，一个类对自己依赖的类越少越好； 也就是说，不管多么复杂，都尽量将逻辑封装在内的内部，对外提供public方法，不泄漏任何信息
* 更简单的定义，只与直接的朋友通信
* 直接的朋友，：每个对象都与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说两个对象之间是朋友关系
  * 耦合方式：依赖。关联，组合\聚合等
  * 直接朋友：A类用到类B类，b是a的成员变量，称直接朋友；A中一个成员，接收一个B，称...。返回一个B
  * 局部变量，不是直接朋友
  * 陌生的类最好不要以局部变量的形式出现在类的内部
*  改进：
  * 避免非直接朋友的耦合	

### 合成复用原则

* 原则是，尽量使用合成、聚合的方式，而不是使用继承



### 设计原则核心思想

* 找出应用可能变化处，独立处理，不要和那些不需要变化的代码混合在一起
* 针对接口编程，而不是实现
* 为了交互对象之间的松耦合设计而努力

### UML图

* 一种用于软件系统和设计的语言工具

  * 一套符号规定，描述软件模型之间和关系
* 依赖关系

  * 类用到了对方，之间即存在依赖关系
  * 如果是类的成员属性
  * 方法的返回值
  * 方法接收的参数类型
  * 方法中使用到
  * 基类 到 类 虚线箭头
* 泛化

  * 继承，依赖关系的特例
  * A类继承了B类，那么就说A和B存在泛化关系
  * 白色三角形 + 实现
* 实现

  * 接口被一个类实现了，依赖关系的特例
  * 白色三角型 + 虚线
* 关联

  * 类与类之间的联系，特例
  * 关联具有导航性，双向关系或者单向关系
* 聚合关系

  * 整体和部分的关系，整体和部分可以分开，关联关系的特例
  * 导航性和多重性
  * 空心菱形+实线
* 组合关系

  * 不可分离，则升级组合关系
  * new
  * 析构函数同时删除（级联删除），也属于组合
  * 实心菱形+实线
* latex 绘制 uml
* 参考：texdoc pgf-umlcd



## 设计模式类型

- 创建型：**单例**，抽象工厂，原型，建造者，工厂

- 结构型：适配器，桥接，**装饰**，组合，外观，享元，**代理**

- 行为：模板方法，命令，访问，迭代器，**观察者**，中介者，备忘录，解释器，状态，策略，责任链



## 23种设计模式

## 创建型

### 单例模式

#### 饿汉式（静态常量）应用实例

1. 构造器私有化
2. 类的内部创建对象
3. 向外暴露一个静态公共方法。getInstance
4. 代码实现

- 优点：写法简单，类装载完成实例化，避免线程同步（创建过程）（https://www.cnblogs.com/tiancai/p/5417767.html?ivk_sa=1024320u）
- 缺点：类装载完成实例化，没有达到lazy loading的效果，如果从头到位未使用，造成内存的浪费
- 可用，单可能造成内存浪费

#### 饿汉（静态代码块）

#### 懒汉式

1. 提供一个静态的公有方法，当使用该方法，才去创建instance

- 优点：lazy loading，if 语句块，多线程下可能导致不安全
- 实际开放，不要用这种方法

#### 线程安全，懒汉式

​	将getinstance变成线程同步的方法，每次调用都要同步，效率太低

#### 双重检查

​	volatile关键字

#### 使用场景

频繁创建和销毁的对象，创建耗时过多或者资源浪费过多，但是又要常用的，如数据库和文件对象



### 工厂模式

#### 简单工厂模式

* 批萨订购

  * 批萨种类多种，便于维护
  * 批萨的制作流程（prepare, bake, cut, box）
  * 完成批萨的订购

* 介绍

  * 创建型模式，工厂模式的一种，**简单工厂模式是由一个工厂对象决定创建那一种产品种类的实例**。简单工厂是工厂模式最简单实用的模式
  * 定义类一个创建对象的类，由这个类来**封装实例化对象的行为**
  * 软件开发种，大量的创建某种或某类某批对象时，就会使用工厂模式


#### 工厂方法模式

* 新的需求
  * 客户点批萨时，可以点不同口味的批萨，比如：北京的奶酪批萨，北京的胡椒，伦敦的奶酪，胡椒，...
* 思路1:使用简单工厂模式
  * 创建不同的简单工厂类，BJFactory , LDFactory
  * 可扩展性不好
* 思路2:工厂方法模式
  * 设计方案：将批萨的实例化功能抽象成抽象方法，在不同口味点餐子类实现
  * 定义了一个创建对象的抽象方法，由子类决定实例化的类，工厂方法模式**将实例化推迟到子类**

#### 抽象工厂模式

* 定义接口创建相关或者有依赖关系的对象簇，而无需指明具体的类
* 抽象工厂模式将简单工厂和工厂方法模式进行整合
* 设计层面看，抽象工厂模式就是对简单工厂模式的改进（进一步抽象）
* 工厂抽象成两层，ABSFactory和具体实现的工厂子类，程序员根据对象类型使用对应的工厂子类。将简单的工厂类变成类了工厂簇，利于代码的维护和扩展

 [AbsFactory.pdf](../../zw_bioinformation/learn_cpp/Design_Patterns/factory/abstractFactory/uml/AbsFactory.pdf) 

#### 小结

- 创建对象实例时，不要new，而是放在工厂方法并返回
- 不要让类继承具体类，而是继承抽象类或interface
- 不要覆盖类中已经实现的方法

### 原型模式

* 克隆羊问题：姓名tom，年龄1，颜色白色，编写抽象克隆10只和tom一样的羊
* 原型模式介绍
  * 用原型实例指定对象的种类，并且通过拷贝这些原型，创建新的对象
  * 创建型设计模式，允许对象再创建另一个可定制的对象，无需知道细节
  * 工作原理：通过一个原型对象传给那个发动创建的对象，这个发动创建的对象通过请求原型对象拷贝他们自己来创建
* 浅拷贝：就是给对象中的每个成员变量进行复制，就是把A1类中的变量直接赋给A2类中变量，属于值传递，但是涉及到有new之类内存分配的地方，他们却是共享内存的。
* 深拷贝：就是不仅使用值传递，而是要每个变量都有自己一份独立的内存空间，互不干扰
* **使用场景**：基本就是你需要从A的实例得到一份与A内容相同，但是又互不干扰的实例的话，就需要使用原型模式。
* 优点
  * 使用拷贝模式比直接new一个对象的开销要小的多。
  * 可以在程序运行时（对象属性发生了变化），得到一份内容相同的实例，但之间还不会相互干扰。
* C++实现参考： https://zhuanlan.zhihu.com/p/119453835

### 建造者模式

- 盖房子问题
  - 过程：打桩，砌墙，封顶
  - 样式：普通房子，高楼，别墅，过程一样，但是要求不同
- 产品和产品建造过程解耦合
- 基本介绍
  - 将复杂对象的建造过程抽象出来，用户无需知道细节，使这个抽象的过程的不同实现方法构建出不同表现的对象
  - 建造者模式是一步一步创建一个复杂的对象，它允许用户指定复杂对象的类型和内容就可以构建他们，用户无需知道内部细节
- 核心角色
  - product（产品角色）:一个具体的产品对象
  - Builder(抽象建造者)：创建一个product对象的各个部件指定的接口类
  - concreteBuilder：具体的建造者，实现接口，构建和装配各个部件
  - Direcetor：指挥者，构建一个bulider对象，它主要用于创建一个复杂的对象。
    - 两个作用：
    - 隔离客户和对象的生产过程
    - 复杂控制对象的生产过程
- 建造者 vs. 抽象工厂
  - 工厂模式注重的是整体对象的**创建方法**，不会关心构建过程，只关心什么产品由什么工厂生产即可
  - 建造者模式注重的是对象的**创建过程**，产品由指定的蓝图规定，主要是按照要求组装零配件产生一个产品，创建对象的过程方法可以在创建时自由调用
- 建造者模式建造的产品一般具有较多的共同点，其组成相似，**产品之间差异大，不适合使用**

## 结构型

### 适配器模式

* 三种，src是怎样形式给到Adapter来命名的
  * 类适配器：以类给到，在Adapter里，src当作类继承
  * 对象适配器：对象给到，src作为一个对象，持有
  * 接口
* 作用：将原本不兼容的接口融合在一起工作
* 转换头问题
  * 各个国家的插板规格不一，需要转接头中转
* 工作原理
  * 将一个接口转换成另一个接口，让原本不兼容的接口兼容
  * 从用户的角度看不到适配者，是解偶的
  * 用户调用适配器转换的接口，适配器在调用相关的接口
* target, adapter, adaptee,client
* https://blog.csdn.net/weixin_33795806/article/details/92342371



### 桥接模式

- 手机
  - 折叠式，直立，旋转式
    - 品牌：huawei，mi，vivo
-    增加一个品牌：苹果；增加一种型号：平板
- 类爆炸增长--> 桥接模式
- 基本介绍
  - 将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变
  - 结构型
  - 基于类的最小设计原则，通过使用封装，聚合及继承等行为让不同的类承担不同的职责
  - 主要的特点，把抽象和行为实现分开，从而可以保持各部分的独立性和他们的功能扩展

- 桥：phone作为桥，可以提供protected方法给子类使用；或者引入一个protected变量给子类使用
- client: 调用者
- 抽象类：维护implementor的子类，聚合关系，充当了桥接
- 抽象类子类：抽象类的具体实现
- implementor：行为实现类的接口
- ConcreteImplementorA/b：行为实现的具体类b     
- 从uml图：这里的抽象类呵呵接口是聚合关系，实际是调用和被调用关系

- 细节
  - 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象和实现部分独立分开，有助于分层设计， 从而产生更好的结构化代码
  - 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就行，其他的部分由具体的业务来完成
  - 桥接模式替代了多继承方案，减少子类个数，降低管理和维护成本
  - 增加了系统的理解和设计的难度，由于聚合关系建立在抽象层，要求开发者针对抽象者进行设计和编程
  - 桥接模式要求正确识别出系统两个独立变化的维度，使用范围有局限
    - 不希望使用继承和多继承导致类的个数急剧增加的系统，适用
    - JDBC驱动
    - 银行转账： 分类：网上，柜台；用户：普通，银卡，金卡

### 装饰者模式
- 星巴克咖啡
  - 咖啡种类：Espresso意大利，shortBlack，LongBlack，Decaf无因
  - 调料：Milk，chocolate
  - 要求：新增咖啡种类时，具有扩展性，改动方便，维护方便
  - OO来计算不同种类的费用：客户可以点单品，也可以单品加调料
  - 问题：单品加调料组合的种类太多，要设计很多类，增加一个单品咖啡或调料，类的数量将倍增

- cafe方案2
 - 将调料内置到drink类里，可以减少类
 - 可以控制类的数量，不至于造成很多类
 - 增加和删除调料时，增加或减少的代码量很大

- 装饰者模式：**动态**的将新功能附加到对象上，在对象功能扩展方面，他比继承更加有弹性，体现了开闭原则
- 原理
  - 装饰者就像打包一个快递
  - 主体：陶瓷，衣服；
    - coffee问题中的单体coffee
  - 包装：报纸，塑料泡沫，纸板木板；
    - 类似调料

### 组合模式



* 学校院系展示，学校->学院->系
  * 传统方法，继承，缺点，has-a关系而不是is-a；不好管理，添加删除遍历
* 组合模式（Composite）
  * 又叫整体模式，创建树形对象，对象组合成树形结构表示**整体-部分**关系
  * 依据**树形结构来组合对象**，层次性
  * 用法对单个或组合对象都具有访问的一致性
* 角色
  * Component:接口，提供默认的行为
  * leaf:叶子节点
  * Composite：非叶子节点，可以管理叶子节点

* 注意事项
  * 简化客户端，客户只需明白谁包含谁，面对一致的对象而不用考虑整体和节点的问题
  * 较强的扩展性，改变组合的层次关系，而不学院改变客户端
  * 方便创造复杂的层次结构,客户端不用理会细节
  * 遍历组织结构或者对象具有树形结构，适合组合模式
  * 需要较高的抽象性，节点和叶子差异性大时，不适合组合模式

### 外观模式

- 组建一个家庭影院

  - DVD，投影仪，自动屏幕，音箱，爆米花机

  - 遥控器控制各个对象完成功能

  - 问题

  - 客户端main方法中。需要创建各个子系统的对象，并直接去调用子系统对象的方法，过程混乱

  - 维护对子系统的操作麻烦

  - 解决的方法：**提供一个一致的接口**，屏蔽内部子系统的细节，调用端只需要调用接口，无需关心细节
- 外观模式（Facade）
  - 过程模式，为子系统中一组接口提供一个一致的界面，此模式定义了一个高层接口，使得子系统调用更加方便
  - 定义一致性接口，屏蔽内部细节，调用端只需调用接口，无需关系内部细节

* 角色
  * 外观类：为调用者提供同一的调用接口，知道那些子系统负责处理请求，从而将调用端的请求代理给适当的子系统对象
  * 调用者：外观接口的调用者
  * 子系统集合：处理facade对象的任务，功能的提供者
* 外观模式解决多个接口带来的使用困难，起到简化的用户操作的作用
  * 子系统间细节不可见，可能子系统互相调用
* 细节和注意事项
  * 屏蔽细节，降低客服端的对子系统的复杂性
  * 外观模式对客户端的耦合关系，容易扩展
  * 合理的外观，可以帮我们更好的划分访问的层次
  * 系统需要分层，可以考虑外观模式
  * 维护一个遗留的大型系统，可能系统非常难维护和扩展，可以考虑facade，提供清晰的接口，提高复用性
  * 不能过多或不合理的使用外观模式，要考虑：使用外观模式好，还是直接调用好，要便于维护

### 享元模式

* 网站外包，一个网站不错，需求稍微改动
  * 新闻形式
  * 博客形式
  * 微信公众号
* 方案一，直接复制粘贴，然后根据方案改；给每个网站租一个空间
  * 问题：结构相似度高，如果多个虚拟空间，浪费资源
  * 解决思路：整合相关的代码和数据，对于硬盘cpu内存数据空间都可以共享
  * 对于代码，都是一份实例，使用享元模式来解决
* 享元模式（Flyweight）
  * 运用共享技术可以有效支持大量细粒度的对象
  * 常用於低层开发，解决性能问题，如数据库连接池，如果有创建好时，直接使用，没有则创建
  * 享元模式，能够解决重复内存浪费的问题，当系统有大量的相似对象，可以从缓冲池里面拿，可以降低内存使用，提高效率
  * 享元模式经典运用场景就是池技术，string常量池，数据库连接池
* 角色
  * Flyweight抽象的享元角色，他是产品的抽象类，同时定义外部状态和内部状态的接口实现
    * 棋子，位置是外部状态，多变；颜色是内部状态
    * 细粒度和共享对象，将对象的信息分成两部分：内部状态和外部状态
    * 围棋有361个空位放棋子，每盘棋可能有300多个棋子对象，对内存要求较高，如果使用享元模式可以减少到2个棋子对象
  * concreteFlyweight具体的享元角色，是具体的产品类，实现抽象角色定义的相关业务
  * unsharedconcreteFlyweight不可共享，一般不会出现在享元工厂
  * FlyweightFactory，工厂类，用于构建一个池容器，同时提供从池中获取对象方法
* 注意事项
  * 享是共享， 元是对象
  * 系统有大量对象，当这些对象消耗大量的内存，并且对象的状态大部分可以外部化，我们可以考虑享元模式
  * 唯一的标识码判断，如果在内存有这个对象则返回，无则创建
  * 能减少对象的创建，降低内存，提高效率
  * 提高了复杂度，需要分离内部和外部状态，内部和外部状态用一个工厂类来控制
  * 经典应用是缓冲池

### 代理模式

- 代理模式：为对象提供一个替身，以控制对这个对象的访问，即通过代理访问对象
  - 好处：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能
- 被代理的对象可以是远程对象、开销大的对象或需要安全控制的对象
- 三种方式：静态代理，动态代理，cglib代理(可以在内存中动态的创建对象，而不需要创建接口，属于动态代理)
- 静态代理
  - 定义接口或父类，被代理的对象与代理对象一起实现相同的接口或者是继承相同的父类
  - 问题：
    - 定义接口iteacherDao
    - 目标对象teacherDAO实现IteacherDao
    - 使用静态代理的方式就需要在teacherDAOProxy实现IteacherDao
    - 调用的时候通过调用代理对象的方法来调用目标对象
    - **特别提醒**：代理对象和目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法
  - 优点：不修改对象，可以实现对功能的扩展
  - 缺点：因为代理对象要与目标对象的接口一致，因此需要很多代理类
  - 一旦增加方法，目标对象和代理对象都要维护

- 动态代理
  - 代理对象不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
  - 代理对象的生成，利用API，动态在内存中构建代理对象
- https://blog.csdn.net/u011047958/article/details/79032216


### 模板模式
- 豆浆程序性
  - 流程：选材->添加配料->浸泡->豆浆机打碎
  - 不同的配料，制作不同的制作不同的口味
  - 选材、浸泡、和放到豆浆机都是一样的
  - 模板方法模式完成
- 模板方法模式（Template Method pattern）
  - 在抽象类公开定义执行它的模板，它的子类按需从新编写，但调用将以抽象类的方式进行
  - **模板方法模式**定义一个操作中的算法骨架，而将一些步骤延迟于类，使得子类可以不改变一个算法的结构，就可以定义算法的某些特征
  - 行为型模式
- 角色
  - AbstractClass是一个抽象类，类中实现了模板方法，定义了算法的骨架，具体子类需要去实现其他的抽象方法
  - ConcreteClass实现了抽象方法，以完成算法中特定子类的相关工作

- 钩子函数
  - 在模板方法中父类，我们定义一个方法，它默认不做任何事，子类视情况覆盖，该方法称为**钩子**
  - 豆浆问题，加入新的纯豆浆，不需要任何配料

- 注意事项
  - 基本思想：算法存在于一个地方，也就是父类中，容易修改，需要修改算法时，只需要修改父类中模板方法和已经实现的某些步骤，子类就会继承这些修改
  - 实现了最大的代码复用，父类的模板方法和已经实现的某些步骤被子类继承直接使用
  - 统一了算法，提供了很大的灵活性，父类的模板方法确保了结构不变
  - 不足：每一个不同的实现豆需要一个子类实现，导致子类过多
  - 模板方法不能被重写
  - 场景：当完成某个过程，该过程执行一系列步骤，这些步骤基本相同，但是个别方法不同，通常考虑模板方法来处理

### 命令模式

- 智能生活需求
  - 家电：冰箱，洗衣机，空调，电风扇等...，只需手机或者遥控器就能控制所有的家电
  - 这些家电来着不同的厂家，每一种家电无需都安装一个app
  - 一个app控制所有家电
  - 考虑使用**命令模式**，可以讲动作的请求者和执行者对象中解耦
  - 这个例子，请求者是app，执行者是家电
- 命令模式（Command）
  - 在软件设计中，我们经常需要向某些对象发送请求，但是不知道接受者是谁，也不知道请求的操作是那个
  - 命令模式让发送者和请求者消除彼此的耦合，让对象调用关系更加灵活
  - 命令模式，**命令封装成一个对象**，以便表示不同的请求，支持撤销
  - 通俗的解释：将军发布命令，士兵去执行
    - 将军：命令的发布者   Invoker
    - 士兵：被调用者 Receiver
    - 命令：Command，连接将军和士兵
- 注意事项
  - 容易设计一个命令队列，实现多线程
  - 容易对命令的撤销和重做 
  - 不足：如果命令很多，需要很多具体的命令类，增加了系统的复杂度
  - 空命令：可以省略判断空，如果没按下一个键都需要判断空命令，编码会比较复杂
  - 命令模式应用：gui，模拟cmd，订单流程等

### 访问者模式

评测系统：观众分成男女两种，对歌手进行评测，当某个歌手表演完以后，得到他们对该歌手的不同评价（评价有不同的种类，比如成功，失败）

* 传统方法：person-> <Man, Women> ; 评价：成功，失败
* 缺陷：系统小还能运作，系统的功能太多时，代码的修改太大
  * 扩展性不好，增加了新的人员，评价
* 使用访问者模式

访问者模式

* 封装一些作用于某种数据结构的各元素的操作，它可以不改变数据结构的前提下定义作用于这些元素的新的操作
* 基本工作原理：在访问的类里面加一个对外提供访问者的接口
* 运用场景：需要对一个对象结构中的对象进行很多不同的操作（这些操作没有关联），同时要避免这些操作污染对象的类

角色

* Visitor：抽象访问者，为该对象结构ConcreteElement的每一个类申明一个visitor操作
* ConcreteVisitor：具体的访问者，实现visitor，每个操作实现的部分
* objectStructure：能枚举元素，可以提供一个高层的接口，来允许访问元素
* Element：定义一个accept，接受一个访问者对象
* ConcreteElement：具体的元素

双分派

* 即首先在客户端程序中
  * 具体的状态作为参数 -- > Woman，第一次
  * `Woman.accept(this)` -->  action，讲自己作为参数第二次
* 不管类怎么变，我们都能找到期望的方法运行
* 双分配意味着执行的操作去决议请求的种类和两个接受者的类型
* 假设添加一个Wait，考察Man类和Woman类的反应，只需要添加一个Action就可以在客户端调用不需要改动其他代码

注意事项
* **优点**：
* 符合单一职责、让程序有优秀的扩展性、灵活性高
* 功能进行统一，可以做报表、UI、拦截器和过滤器，结构相对稳定的系统
* **缺点**
* 具体的元素要对访问者公布细节，也就是访问者关注了其他类的具体细节，这是访问者模式不建议的
* 违背了依赖倒转法则，访问者依赖的是具体元素，而不是抽象元素
* **因此**：如果一个系统有比较稳定的数据结构，又需要经常变化功能需求，那么访问者模式是合适的

### 迭代器模式

- 学校学院打印问题，便利问题

  - 计算机学院-- 数组中，信息工程学院--集合
  - 统一的迭代器，对各个学院进行遍历

- 迭代器（iterator）

  - 如果我们的集合是不同的方法实现的，数组，集合等，当客户端要遍历这些集合时，就需要多种遍历方法，这会暴露元素的内部结构，可以考虑迭代器模式
  - 迭代器为所有的结合遍历提供统一的接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示

- 角色

  - Iterator：迭代器接口，提供遍历的方法

  - ConcreteIterator：具体的迭代器

  - Aggregate：一个统一聚合接口，将客户端和具体聚合解耦

  - ConcreteAggregate：具体的聚合持有的对象集合，提供一个方法，返回一个迭代器，该迭代器可以正确遍历集合

  - ###### Client：依赖Iterator和Aggregate他们的子类

- https://blog.csdn.net/u012611878/article/details/78010435

* 注意事项
  * 优点
  * 提供统一的方法遍历，不用考虑聚合的类型，使用一种方法就可以遍历对象了
  * 隐藏了内部的结构，客户端要遍历聚合的时候只能取迭代器，而不知道内部细节
  * 提供一种思想，一个类应该只有一个引起变化的原因。聚合类中，迭代器分开，就是要把管理对象和遍历对象集合分开，集合改变，只影响聚合对象，遍历方式改变，只需改变迭代器
  * 当要展示相似对象时，适合迭代器
  * 缺点：
  * 每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类

### 观察者模式

- 天气预报问题
  - 气象站可以讲每天测量的温度、湿度、气压等公告的方式发布出去，发布到自己的网站或者第三方
  - 开放性API，便于其他第三方获取数据
  - 提供温度、湿度、气压的接口
  - 测量数据更新，及时反馈到第三方
-  问题
  - 其他第三方接入气象站获取数据的问题
  - 无法在运行运行时动态的添加第三方
  - 违反ocp原则
- 观察者模式
  - 类似顶牛奶业务
  - 奶站、气象局：Subject
  - 用户、第三方：observer，update方法
  - subject三个核心方法：注册用户，删除用户，通知
  - 观察者模式：多对一的一种设计方案，被依赖的是Subject，依赖的对象是Observer，subject通知observer的变化。奶站、气象站是1的一方，第三方是多的一方
-  注意事项
  - 优点：观察者模式设计后，以集合的方式管理用户，包括注册，移除和通知
  - 我们增加观察者就无需更改weather，遵守了ocp



### 中介者模式

*  智能家庭管理问题
  * 各种设备：闹钟，咖啡机，电视机，窗帘
  * 主人开电视时，各个设备协同工作，流程：闹钟响起->咖啡机开始->窗帘落下->电视机开始播放
* 问题分析
  * 当电器有多种状态可以改变时，相互之间的调用关系会比较复杂
  * 各个电器对象彼此有联系，不利于送耦合
  * 各个对象之间相互传递信息，容易混乱
  * 系统增加一个对象时，执行流程改变时，代码的可维护性都不理想
* 中介者模式（Mediator）
  * 用一个中介对象来封装一系列的对象交互，使各个对象来封装一系列对象交互
  * 中介者各个对象不需要显式的相互调用，从而使其松耦合，而且可以独立地改变他们之间的交互
  * 中介者模式属于行为模式，使代码容易维护
  * MVC模式C，是M和V的中介，使前后端交互起到了中间人作用
* 角色
  * Mediator抽象中介，定义了同事对象到中介者对象的接口
  * Colleague：是同事类
  * ConcreteMediator：具体的抽象类，实现抽象的方法，他需要所有的具体的同事类组成一个集合共同管理，处理实务
  * ConcreteMediator：具体的同事类，每个同事只知道自己的行为，不理解其他同事的行为，但是都依赖于中介者
* 注意事项
  * 多个类相互联系，形成网状结构，使用中介者模式将网状结构分离成星形结构，进行解耦
  * 减少类依赖，降低耦合，符合迪米特
  * 中介者承担了较多的责任，一旦出了问题，整个系统将受到影响
  * 如果设计不当，中介者自己将非常复杂
*  https://blog.csdn.net/SDDDLLL/article/details/100040720

### 备忘录模式

* 游戏角色状态恢复问题
  * 游戏角色有攻击和防御，打boss时保存以前的，攻击和防御增强，打完boss恢复原来的状态
* 问题
  * 一个对象，对应一个游戏对象的状态，当对象多时，不利于管理，开销大
  * 传统的方式是备份，new一个，需要的时候再拿出来，但是这样会暴露类的细节
* 备忘录模式（Memento）
  * 不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这状态，这样以后就能讲对象恢复到这个状态
  * 理解：现实的备忘录是用来做某些笔记，或者是某些已经达成公共意见的使其，以防忘记；软件层面，具有相同的含义，记录一个对象的状态，当回退时，再恢复状态
* 角色
  * Originator：对象，需要保存状态的对象
  * Memento：备忘录对象，负责保存好记录，即Originator内部的状态
  * Caretaker：守护者对象，负责保存多个备忘录对象，使用集合管理，提高效率
  * 如果希望保存多个Originator对象不同对象不同状态也可以，map<string, 集合>
* 注意事项
  * 提供了一种恢复机制，比较方便的回到历史版本
  * 实现了信息的封装，使不需要关心内部的细节
  * 变量过多，讲耗费大量的资源，每一次保存都会消耗
  * 适应场景：后悔药，存档，撤销和重做，数据库的实务处理
  * 为了节约内存，可以和原型模式配合使用

### 解释器模式

- 编译原理中，一个算术表达式可以通过词法分析器形成词法单元，而后这些单元通过语法分析器建构分析树，最后形成一颗抽象的语法分析树。这里的词法分析和语法分析树都可以看出解释器
- 解释器模式：（Interpreter）指定一个语言表达式，定义他的文法的一种，并定义一个解释器，使用该解释器来解释语言中的句子
- 场景：
  - 应用一个需要执行解释执行的语言中的句子表示为一个抽象的模式
  - 一些重复出现的问题可以用一种简单的语言来表达
  - 一个简单语法需要解释的场景
  - 常用于：编译器、运算器表达式、正则表达式、机器人等
-  角色
  - context：环境角色，含有解释器之外的全局信息
  - AbsExpression：抽象表达式，申明一个抽象的操作，这个方法让语法树中所有的节点共享
  - TerminalExpression：为终结符相关解释
  - NonTerminalExpression：非终结相关解释 
  - context和termianl通过client输入
- 注意事项
  - 一个语言需要解释执行，可以将语言中的句子抽象成一个语法树，就可以考虑解释器模式，让程序的执行有良好的扩展性
  - 问题：类膨胀，解释器采用递归调用的方法，将导致调试复杂，效率降低

### 状态模式

* 主要解决多种状态的转换，需要对外输出不同行为的问题。状态和行为是一一对应的，之间可以相互转换
* 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类
* 角色
  * Context：上下文环境角色，用于维护ConcreteState实例，这个实例定义了当前的状态
  * state：抽象接口，封装与context的一个特定接口相关行为
  * concreteState：具体的状态角色，每个子类实现一个与context相关的行为
* 注意事项
  * 很强的可读性，每个状态封装到类
  * 方便维护，减少if else 语句
  * 符合开闭原则，容易增删
  * 产生很多类，每个状态对应一个类，类太多，维护变难
  * 当一个事件有很多状态时，状态之间相互转换，对不同的状态有不同的需求时，可以考虑状态模式

### 策略模式

- 鸭子问题
  - 各种鸭子，野鸭子，北京鸭，各自动作
  - 传统的方案，duck类，子类各种不同种类的duck
- 策略模式（Strategy）
  - 定义算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的用户
  - 体现了几个设计原则
    - 变化的代码从不变的代码分离出去
    - 针对接口编程而不是类
    - 多用组合聚合，少用继承（客户通过组合方式使用策略）
- 角色
  - 从类图，可以看到客户有成员变量Strategy，或者其他的strategy，至于需要使用到那些策略，可以从构造器指定
- 注意事项
  - 关键：识别项目的不变和变化的部分
  - 核心思想：多用组合，聚合，少用继承
  - 体现了**对修改关闭，对扩展开放的原则**，客户端不用修改源码，只需要增添策略即可，避免使用if else
  - 提供了可以替换继承的方法：算法封装到strategy类中，使得可以独立于context改变，使得易于切换，扩展
  - 注意的是：增加一个策略就要增加一个类，使得类过多

### 责任链模式

* 采购项目
  * 采购器材：
    * 小于等于5000，教学主任审批
    * 小于1w，院长审批
    * 小于3w，副校长
    * 超过3w，校长
* 问题：
  * 大量的分支判断
  * 如果任意一个金额发生改变，修改繁琐
  * 客户应该明确的知道审批 级别
  * 请求和审批人强耦合，不利于扩展
* 责任链模式 （Chain of Responsibility）
  * 为请求创建了一个接受者对象的链，这种链对发送者和接受者解耦
  * 每个接受者包含一个对另一个接受者的引用，如果不能解决，则传给引用的接受者
*  角色
  * Handler：抽象的处理者，定义了一个处理请求的方法，同时包含另一个handler
  * concreteHandler，具体的处理者，处理他自己负责的请求，可以访问后一个后继者，如果可以处理则自己处理，不行就交给后继者，形成职责链
  * reque：请求类
* 注意事项
  * 处理和请求分开，实现解耦，提高系统灵活性
  * 简化对象，对象不需要知道链的结构
  * 性能会受到影响，特别是链长时，因此需要控制链最大节点数量，一般通过在handler设置一个最大节点数量
  * 调试不方便，类似递归的方式，逻辑复杂
  * 运用场景：多个对象处理一个请求时，比如：多级请求，请假加薪等审批流程，java web中的 tomcat对Encoding的处理

